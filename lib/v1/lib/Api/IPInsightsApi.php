<?php

/**
 * IPInsightsApi
 * PHP version 8.1
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @link     https://openapi-generator.tech
 */

/**
 * Opportify Insights API
 *
 * ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, private or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.17.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

/**
 * IPInsightsApi Class Doc Comment
 *
 * @category Class
 *
 * @author   OpenAPI Generator team
 *
 * @link     https://openapi-generator.tech
 */
class IPInsightsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] * */
    public const contentTypes = [
        'analyzeIp' => [
            'application/json',
        ],
        'batchAnalyzeIps' => [
            'application/json',
            'multipart/form-data',
            'text/plain',
        ],
        'createIpBatchExport' => [
            'application/json',
        ],
        'getIpBatchExportStatus' => [
            'application/json',
        ],
        'getIpBatchStatus' => [
            'application/json',
        ],
    ];

    /**
     * @param  int  $hostIndex  (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client;
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector;
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param  int  $hostIndex  Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation analyzeIp
     *
     * Analyze IP
     *
     * @param  \OpenAPI\Client\Model\AnalyzeIpRequest  $analyze_ip_request  analyze_ip_request (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['analyzeIp'] to see the possible values for this operation
     * @return \OpenAPI\Client\Model\AnalyzeIp200Response|\OpenAPI\Client\Model\AnalyzeIp400Response|\OpenAPI\Client\Model\NOTFOUND|\OpenAPI\Client\Model\AnalyzeEmail403Response|\OpenAPI\Client\Model\INTERNALERROR1
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function analyzeIp($analyze_ip_request, string $contentType = self::contentTypes['analyzeIp'][0])
    {
        [$response] = $this->analyzeIpWithHttpInfo($analyze_ip_request, $contentType);

        return $response;
    }

    /**
     * Operation analyzeIpWithHttpInfo
     *
     * Analyze IP
     *
     * @param  \OpenAPI\Client\Model\AnalyzeIpRequest  $analyze_ip_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['analyzeIp'] to see the possible values for this operation
     * @return array of \OpenAPI\Client\Model\AnalyzeIp200Response|\OpenAPI\Client\Model\AnalyzeIp400Response|\OpenAPI\Client\Model\NOTFOUND|\OpenAPI\Client\Model\AnalyzeEmail403Response|\OpenAPI\Client\Model\INTERNALERROR1, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function analyzeIpWithHttpInfo($analyze_ip_request, string $contentType = self::contentTypes['analyzeIp'][0])
    {
        $request = $this->analyzeIpRequest($analyze_ip_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyzeIp200Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyzeIp400Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\NOTFOUND',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyzeEmail403Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\INTERNALERROR1',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AnalyzeIp200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeIp200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeIp400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NOTFOUND',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeEmail403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\INTERNALERROR1',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation analyzeIpAsync
     *
     * Analyze IP
     *
     * @param  \OpenAPI\Client\Model\AnalyzeIpRequest  $analyze_ip_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['analyzeIp'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function analyzeIpAsync($analyze_ip_request, string $contentType = self::contentTypes['analyzeIp'][0])
    {
        return $this->analyzeIpAsyncWithHttpInfo($analyze_ip_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation analyzeIpAsyncWithHttpInfo
     *
     * Analyze IP
     *
     * @param  \OpenAPI\Client\Model\AnalyzeIpRequest  $analyze_ip_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['analyzeIp'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function analyzeIpAsyncWithHttpInfo($analyze_ip_request, string $contentType = self::contentTypes['analyzeIp'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AnalyzeIp200Response';
        $request = $this->analyzeIpRequest($analyze_ip_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'analyzeIp'
     *
     * @param  \OpenAPI\Client\Model\AnalyzeIpRequest  $analyze_ip_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['analyzeIp'] to see the possible values for this operation
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    public function analyzeIpRequest($analyze_ip_request, string $contentType = self::contentTypes['analyzeIp'][0])
    {

        // verify the required parameter 'analyze_ip_request' is set
        if ($analyze_ip_request === null || (is_array($analyze_ip_request) && count($analyze_ip_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $analyze_ip_request when calling analyzeIp'
            );
        }

        $resourcePath = '/ip/analyze';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($analyze_ip_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($analyze_ip_request));
            } else {
                $httpBody = $analyze_ip_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-opportify-token');
        if ($apiKey !== null) {
            $headers['x-opportify-token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batchAnalyzeIps
     *
     * Batch Analyze IPs
     *
     * @param  \OpenAPI\Client\Model\BatchAnalyzeIpsRequest  $batch_analyze_ips_request  batch_analyze_ips_request (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['batchAnalyzeIps'] to see the possible values for this operation
     * @return \OpenAPI\Client\Model\BatchAnalyzeIps202Response|\OpenAPI\Client\Model\BatchAnalyzeIps400Response|\OpenAPI\Client\Model\BatchAnalyzeEmails401Response|\OpenAPI\Client\Model\BatchAnalyzeEmails402Response|\OpenAPI\Client\Model\BatchAnalyzeEmails403Response|\OpenAPI\Client\Model\BatchAnalyzeEmails413Response|\OpenAPI\Client\Model\BatchAnalyzeEmails429Response|\OpenAPI\Client\Model\AnalyzeEmail500Response
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function batchAnalyzeIps($batch_analyze_ips_request, string $contentType = self::contentTypes['batchAnalyzeIps'][0])
    {
        [$response] = $this->batchAnalyzeIpsWithHttpInfo($batch_analyze_ips_request, $contentType);

        return $response;
    }

    /**
     * Operation batchAnalyzeIpsWithHttpInfo
     *
     * Batch Analyze IPs
     *
     * @param  \OpenAPI\Client\Model\BatchAnalyzeIpsRequest  $batch_analyze_ips_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['batchAnalyzeIps'] to see the possible values for this operation
     * @return array of \OpenAPI\Client\Model\BatchAnalyzeIps202Response|\OpenAPI\Client\Model\BatchAnalyzeIps400Response|\OpenAPI\Client\Model\BatchAnalyzeEmails401Response|\OpenAPI\Client\Model\BatchAnalyzeEmails402Response|\OpenAPI\Client\Model\BatchAnalyzeEmails403Response|\OpenAPI\Client\Model\BatchAnalyzeEmails413Response|\OpenAPI\Client\Model\BatchAnalyzeEmails429Response|\OpenAPI\Client\Model\AnalyzeEmail500Response, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function batchAnalyzeIpsWithHttpInfo($batch_analyze_ips_request, string $contentType = self::contentTypes['batchAnalyzeIps'][0])
    {
        $request = $this->batchAnalyzeIpsRequest($batch_analyze_ips_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeIps202Response',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeIps400Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails401Response',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails402Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails403Response',
                        $request,
                        $response,
                    );
                case 413:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails413Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails429Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyzeEmail500Response',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BatchAnalyzeIps202Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeIps202Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeIps400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 413:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails413Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeEmail500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation batchAnalyzeIpsAsync
     *
     * Batch Analyze IPs
     *
     * @param  \OpenAPI\Client\Model\BatchAnalyzeIpsRequest  $batch_analyze_ips_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['batchAnalyzeIps'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function batchAnalyzeIpsAsync($batch_analyze_ips_request, string $contentType = self::contentTypes['batchAnalyzeIps'][0])
    {
        return $this->batchAnalyzeIpsAsyncWithHttpInfo($batch_analyze_ips_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchAnalyzeIpsAsyncWithHttpInfo
     *
     * Batch Analyze IPs
     *
     * @param  \OpenAPI\Client\Model\BatchAnalyzeIpsRequest  $batch_analyze_ips_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['batchAnalyzeIps'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function batchAnalyzeIpsAsyncWithHttpInfo($batch_analyze_ips_request, string $contentType = self::contentTypes['batchAnalyzeIps'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BatchAnalyzeIps202Response';
        $request = $this->batchAnalyzeIpsRequest($batch_analyze_ips_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchAnalyzeIps'
     *
     * @param  \OpenAPI\Client\Model\BatchAnalyzeIpsRequest  $batch_analyze_ips_request  (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['batchAnalyzeIps'] to see the possible values for this operation
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    public function batchAnalyzeIpsRequest($batch_analyze_ips_request, string $contentType = self::contentTypes['batchAnalyzeIps'][0])
    {

        // verify the required parameter 'batch_analyze_ips_request' is set
        if ($batch_analyze_ips_request === null || (is_array($batch_analyze_ips_request) && count($batch_analyze_ips_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_analyze_ips_request when calling batchAnalyzeIps'
            );
        }

        $resourcePath = '/ip/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_analyze_ips_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_analyze_ips_request));
            } else {
                $httpBody = $batch_analyze_ips_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-opportify-token');
        if ($apiKey !== null) {
            $headers['x-opportify-token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createIpBatchExport
     *
     * Create IP Batch Export
     *
     * @param  string  $job_id  The unique identifier of the completed batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  \OpenAPI\Client\Model\ExportRequest|null  $export_request  export_request (optional)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['createIpBatchExport'] to see the possible values for this operation
     * @return \OpenAPI\Client\Model\ExportCreatedResponse|\OpenAPI\Client\Model\CreateEmailBatchExport400Response|\OpenAPI\Client\Model\CreateEmailBatchExport403Response|\OpenAPI\Client\Model\CreateEmailBatchExport404Response|\OpenAPI\Client\Model\CreateEmailBatchExport409Response
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function createIpBatchExport($job_id, $export_request = null, string $contentType = self::contentTypes['createIpBatchExport'][0])
    {
        [$response] = $this->createIpBatchExportWithHttpInfo($job_id, $export_request, $contentType);

        return $response;
    }

    /**
     * Operation createIpBatchExportWithHttpInfo
     *
     * Create IP Batch Export
     *
     * @param  string  $job_id  The unique identifier of the completed batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  \OpenAPI\Client\Model\ExportRequest|null  $export_request  (optional)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['createIpBatchExport'] to see the possible values for this operation
     * @return array of \OpenAPI\Client\Model\ExportCreatedResponse|\OpenAPI\Client\Model\CreateEmailBatchExport400Response|\OpenAPI\Client\Model\CreateEmailBatchExport403Response|\OpenAPI\Client\Model\CreateEmailBatchExport404Response|\OpenAPI\Client\Model\CreateEmailBatchExport409Response, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function createIpBatchExportWithHttpInfo($job_id, $export_request = null, string $contentType = self::contentTypes['createIpBatchExport'][0])
    {
        $request = $this->createIpBatchExportRequest($job_id, $export_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ExportCreatedResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreateEmailBatchExport400Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreateEmailBatchExport403Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreateEmailBatchExport404Response',
                        $request,
                        $response,
                    );
                case 409:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreateEmailBatchExport409Response',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ExportCreatedResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportCreatedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateEmailBatchExport400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateEmailBatchExport403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateEmailBatchExport404Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateEmailBatchExport409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation createIpBatchExportAsync
     *
     * Create IP Batch Export
     *
     * @param  string  $job_id  The unique identifier of the completed batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  \OpenAPI\Client\Model\ExportRequest|null  $export_request  (optional)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['createIpBatchExport'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function createIpBatchExportAsync($job_id, $export_request = null, string $contentType = self::contentTypes['createIpBatchExport'][0])
    {
        return $this->createIpBatchExportAsyncWithHttpInfo($job_id, $export_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createIpBatchExportAsyncWithHttpInfo
     *
     * Create IP Batch Export
     *
     * @param  string  $job_id  The unique identifier of the completed batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  \OpenAPI\Client\Model\ExportRequest|null  $export_request  (optional)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['createIpBatchExport'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function createIpBatchExportAsyncWithHttpInfo($job_id, $export_request = null, string $contentType = self::contentTypes['createIpBatchExport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportCreatedResponse';
        $request = $this->createIpBatchExportRequest($job_id, $export_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createIpBatchExport'
     *
     * @param  string  $job_id  The unique identifier of the completed batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  \OpenAPI\Client\Model\ExportRequest|null  $export_request  (optional)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['createIpBatchExport'] to see the possible values for this operation
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    public function createIpBatchExportRequest($job_id, $export_request = null, string $contentType = self::contentTypes['createIpBatchExport'][0])
    {

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling createIpBatchExport'
            );
        }

        $resourcePath = '/ip/batch/{jobId}/exports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{'.'jobId'.'}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($export_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($export_request));
            } else {
                $httpBody = $export_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-opportify-token');
        if ($apiKey !== null) {
            $headers['x-opportify-token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'POST',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIpBatchExportStatus
     *
     * Get IP Batch Export Status
     *
     * @param  string  $job_id  The unique identifier of the batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  string  $export_id  The unique identifier of the export job. Format: uuid. Example: \&quot;3b90d156-a0d8-4630-8230-f59e9a4e9e33\&quot;. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchExportStatus'] to see the possible values for this operation
     * @return \OpenAPI\Client\Model\ExportStatusResponse|\OpenAPI\Client\Model\GetEmailBatchExportStatus400Response|\OpenAPI\Client\Model\CreateEmailBatchExport403Response|\OpenAPI\Client\Model\GetEmailBatchExportStatus404Response
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getIpBatchExportStatus($job_id, $export_id, string $contentType = self::contentTypes['getIpBatchExportStatus'][0])
    {
        [$response] = $this->getIpBatchExportStatusWithHttpInfo($job_id, $export_id, $contentType);

        return $response;
    }

    /**
     * Operation getIpBatchExportStatusWithHttpInfo
     *
     * Get IP Batch Export Status
     *
     * @param  string  $job_id  The unique identifier of the batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  string  $export_id  The unique identifier of the export job. Format: uuid. Example: \&quot;3b90d156-a0d8-4630-8230-f59e9a4e9e33\&quot;. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchExportStatus'] to see the possible values for this operation
     * @return array of \OpenAPI\Client\Model\ExportStatusResponse|\OpenAPI\Client\Model\GetEmailBatchExportStatus400Response|\OpenAPI\Client\Model\CreateEmailBatchExport403Response|\OpenAPI\Client\Model\GetEmailBatchExportStatus404Response, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getIpBatchExportStatusWithHttpInfo($job_id, $export_id, string $contentType = self::contentTypes['getIpBatchExportStatus'][0])
    {
        $request = $this->getIpBatchExportStatusRequest($job_id, $export_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ExportStatusResponse',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetEmailBatchExportStatus400Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CreateEmailBatchExport403Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetEmailBatchExportStatus404Response',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ExportStatusResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ExportStatusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetEmailBatchExportStatus400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateEmailBatchExport403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetEmailBatchExportStatus404Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation getIpBatchExportStatusAsync
     *
     * Get IP Batch Export Status
     *
     * @param  string  $job_id  The unique identifier of the batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  string  $export_id  The unique identifier of the export job. Format: uuid. Example: \&quot;3b90d156-a0d8-4630-8230-f59e9a4e9e33\&quot;. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchExportStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchExportStatusAsync($job_id, $export_id, string $contentType = self::contentTypes['getIpBatchExportStatus'][0])
    {
        return $this->getIpBatchExportStatusAsyncWithHttpInfo($job_id, $export_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIpBatchExportStatusAsyncWithHttpInfo
     *
     * Get IP Batch Export Status
     *
     * @param  string  $job_id  The unique identifier of the batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  string  $export_id  The unique identifier of the export job. Format: uuid. Example: \&quot;3b90d156-a0d8-4630-8230-f59e9a4e9e33\&quot;. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchExportStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchExportStatusAsyncWithHttpInfo($job_id, $export_id, string $contentType = self::contentTypes['getIpBatchExportStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ExportStatusResponse';
        $request = $this->getIpBatchExportStatusRequest($job_id, $export_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIpBatchExportStatus'
     *
     * @param  string  $job_id  The unique identifier of the batch job. Format: uuid. Example: \&quot;52b36b1f-0c21-41fa-8a4f-423d25a9a8e2\&quot;. (required)
     * @param  string  $export_id  The unique identifier of the export job. Format: uuid. Example: \&quot;3b90d156-a0d8-4630-8230-f59e9a4e9e33\&quot;. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchExportStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchExportStatusRequest($job_id, $export_id, string $contentType = self::contentTypes['getIpBatchExportStatus'][0])
    {

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getIpBatchExportStatus'
            );
        }

        // verify the required parameter 'export_id' is set
        if ($export_id === null || (is_array($export_id) && count($export_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $export_id when calling getIpBatchExportStatus'
            );
        }

        $resourcePath = '/ip/batch/{jobId}/exports/{exportId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{'.'jobId'.'}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }
        // path params
        if ($export_id !== null) {
            $resourcePath = str_replace(
                '{'.'exportId'.'}',
                ObjectSerializer::toPathValue($export_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-opportify-token');
        if ($apiKey !== null) {
            $headers['x-opportify-token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIpBatchStatus
     *
     * Get IP Batch Status
     *
     * @param  string  $job_id  The unique identifier of the batch job to retrieve status for. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchStatus'] to see the possible values for this operation
     * @return \OpenAPI\Client\Model\GetIpBatchStatus200Response|\OpenAPI\Client\Model\BatchAnalyzeEmails401Response|\OpenAPI\Client\Model\BatchAnalyzeEmails402Response|\OpenAPI\Client\Model\BatchAnalyzeEmails403Response|\OpenAPI\Client\Model\GetEmailBatchStatus404Response|\OpenAPI\Client\Model\BatchAnalyzeEmails429Response|\OpenAPI\Client\Model\AnalyzeEmail500Response
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getIpBatchStatus($job_id, string $contentType = self::contentTypes['getIpBatchStatus'][0])
    {
        [$response] = $this->getIpBatchStatusWithHttpInfo($job_id, $contentType);

        return $response;
    }

    /**
     * Operation getIpBatchStatusWithHttpInfo
     *
     * Get IP Batch Status
     *
     * @param  string  $job_id  The unique identifier of the batch job to retrieve status for. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchStatus'] to see the possible values for this operation
     * @return array of \OpenAPI\Client\Model\GetIpBatchStatus200Response|\OpenAPI\Client\Model\BatchAnalyzeEmails401Response|\OpenAPI\Client\Model\BatchAnalyzeEmails402Response|\OpenAPI\Client\Model\BatchAnalyzeEmails403Response|\OpenAPI\Client\Model\GetEmailBatchStatus404Response|\OpenAPI\Client\Model\BatchAnalyzeEmails429Response|\OpenAPI\Client\Model\AnalyzeEmail500Response, HTTP status code, HTTP response headers (array of strings)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     */
    public function getIpBatchStatusWithHttpInfo($job_id, string $contentType = self::contentTypes['getIpBatchStatus'][0])
    {
        $request = $this->getIpBatchStatusRequest($job_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            switch ($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetIpBatchStatus200Response',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails401Response',
                        $request,
                        $response,
                    );
                case 402:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails402Response',
                        $request,
                        $response,
                    );
                case 403:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails403Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetEmailBatchStatus404Response',
                        $request,
                        $response,
                    );
                case 429:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails429Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyzeEmail500Response',
                        $request,
                        $response,
                    );
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetIpBatchStatus200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetIpBatchStatus200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetEmailBatchStatus404Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BatchAnalyzeEmails429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyzeEmail500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }

            throw $e;
        }
    }

    /**
     * Operation getIpBatchStatusAsync
     *
     * Get IP Batch Status
     *
     * @param  string  $job_id  The unique identifier of the batch job to retrieve status for. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchStatusAsync($job_id, string $contentType = self::contentTypes['getIpBatchStatus'][0])
    {
        return $this->getIpBatchStatusAsyncWithHttpInfo($job_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIpBatchStatusAsyncWithHttpInfo
     *
     * Get IP Batch Status
     *
     * @param  string  $job_id  The unique identifier of the batch job to retrieve status for. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchStatusAsyncWithHttpInfo($job_id, string $contentType = self::contentTypes['getIpBatchStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetIpBatchStatus200Response';
        $request = $this->getIpBatchStatusRequest($job_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); // stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIpBatchStatus'
     *
     * @param  string  $job_id  The unique identifier of the batch job to retrieve status for. (required)
     * @param  string  $contentType  The value for the Content-Type header. Check self::contentTypes['getIpBatchStatus'] to see the possible values for this operation
     * @return \GuzzleHttp\Psr7\Request
     *
     * @throws \InvalidArgumentException
     */
    public function getIpBatchStatusRequest($job_id, string $contentType = self::contentTypes['getIpBatchStatus'][0])
    {

        // verify the required parameter 'job_id' is set
        if ($job_id === null || (is_array($job_id) && count($job_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $job_id when calling getIpBatchStatus'
            );
        }

        $resourcePath = '/ip/batch/{jobId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // path params
        if ($job_id !== null) {
            $resourcePath = str_replace(
                '{'.'jobId'.'}',
                ObjectSerializer::toPathValue($job_id),
                $resourcePath
            );
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json'],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem,
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                // if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-opportify-token');
        if ($apiKey !== null) {
            $headers['x-opportify-token'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);

        return new Request(
            'GET',
            $operationHost.$resourcePath.($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @return array of http client options
     *
     * @throws \RuntimeException on file opening failure
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: '.$this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); // stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders(),
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
